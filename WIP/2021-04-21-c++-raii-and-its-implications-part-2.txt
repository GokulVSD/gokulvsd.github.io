---
title: "C++: RAII and its implications Part 2"
tags: [C++, Language]
style: border
color: primary
description: Next up, move semantics for STL containers and exception handling (stack unwinding). 
---

## Move semantics

Using the RAII paradigm in C++ has even more benefits. In addition to constructors and destructors, C++ objects also have copy constructors, 
move constructors and operator constructors.

Here are how they can be defined:
```c++
class Box {
public:
	Box() {
		// Constructor
	}

	~Box() {
		// Destructor
	}

	<return_type> operator =(const Box &b) {
		/* Assignment operator constructor
		invoked when an already initialised object is assigned another object.
		eg:
		Box b1, b2;
		b1 = b2;
		same as doing: b1.operator=(b2);
		return_type can be void for pure unary operators (b++;), 
		can be the class type for unary and expression (a = b++;),
		and can be reference to class type, you can do so by putting Box& as
		<return_type>, and doing: b1 = b2; would make b1 point to the same
		object as b2
		*/
	}
	
	Box(const Box &b) {
		/* Copy constructor
		invoked when an unitialised object is assigned another object.
		eg:
		Box b2;
		Box b1 = b2;
		same as doing: Box b1(b2);
		*/
	}

	Box(Box &&b) {
		/* Move constructor
		Invoked when you do:
		Box b;
		Box a = std::move(b);
		std::move() returns an rvalue (&&) of b
		same as doing: Box a(std::move(b));
		This type of constructor steals resources
		from the passed in object, either by calling
		std::move() on member variables of the object,
		or be assignming them to variables of this
		object, and setting them to default values
		in the passed object (so that the destructor
		for the passed object doesn't deallocate the
		moved resource)
		*/
	}
}
```

Modern C++ and the STL library defined elegant containers like `std::string` and `std::vector`, etc. that can very efficienty perform
operations that involve shifting around their elements.

Traditionally, without having a RAII and therefore without a move constructor, any operation than involved shifting elements around
(say due to sorting, or increasing the container size because it is full) would involve having to copy the elements over into a new memory location.

This can get very expensive, consider a `std::string`, it can contain a huge number of `char`, and if a vector of strings needs to be resized,
memory for a new larger vector would need to be allocated elsewhere, and **every** existing std::string would need to be copied over to the new
location, which includes copying **every** `char` in every `std::string`.

With move semantics, that are a consequential benefit of RAII, when resizing the same vector, instead of copying every char in every string over,
we can move (steal) the resources from the `std::string` from the original vector. The `char` collection within a `std::string` is stored somewhere
in memory right? Why don't we just copy over just the pointer to this memory into the new `std::string` in the newly allocated vector? That is
exactly what the move constructor does. 

As you can imagine, this scales very well, say you have a container of a container of a container. Each outer container can call the move constructors
of the inner containers, and so on, until the primitive data types or pointers are encountered, which are copied over. The container that had its
resources moved? We don't need to care about it. After moving, its resources are set to their defaults, and when it goes out of scope, it will get destructed
automacically.

This is the reason why STL containers are so fast, and why you should always use them instead of writing your own container from scratch whenever possible.
You get this massive speed up, without writing any additonal code whatsoever.


## Exception Handling in C++

With the core principles of RAII out of the way, we can begin to get into some of the differences between C++ and other languages, and the rationale behind them.





