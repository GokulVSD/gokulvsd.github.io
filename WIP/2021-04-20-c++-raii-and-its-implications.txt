---
title: "C++: RAII and its implications Part 1"
tags: [C++, Language]
style: border
color: primary
description: I dive into the RAII paradigm while discussing solutions to issues with dynamic memory allocation. 
---

## Inspiration

The inspiration to write this post was a course on Pluralsight for modern C++ 17, where I heard a comment from the instructor discouraging the use of `new`.
This led me down a rabit hole, allowing me to discover cool features of modern C++ I had no idea about, in my pursuit of writing readable and efficient code.

By discouraging the use of `new`, the instructor was indirectly encouraging the use of one memory allocation paradigm over another.
In other words, use **automatic memory allocation** (on the stack) instead of **dynamic memory allocation** (in the heap). There are many reasons for this,
some are obvious, while others, not so much. I'll first give some context before diving in.

## The Stack

The stack allocates memory in a layered fashion. The consequence of this is that you know exactly what and how much is allocated for each scope.
This is the memory allocation technique for local variables in many programming languages. It is extremely fast because it requires minimal bookkeeping. The
address range for deallocation when leaving a scope is implicit, and so is the starting address to allocate when entering a scope.

In C++, this is called **automatic storage** because the storage is claimed automatically at the end of scope.
Memory for all variables in the scope (delimited by `{}`) is automatically collected.
This is also the moment where destructors are invoked on every object in the scope to clean up resources.

## The Heap
The reason you would allocate memory in the heap instead of on the stack is for flexibility.
Bookkeeping is more complex and allocation is slower. Because there is no implicit release point, you must release the memory manually, 
using `delete` (`free` in C). However, the absence of an implicit release point is the key to the heap's flexibility.

Even though using the heap is slower and opens the door to possible memory leaks or memory fragmentation, there are perfectly good use cases for dynamic allocation, 
as it's less limited.

### Two key reasons to use dynamic allocation:

* You don't know how much memory you need at compile time. For instance, when reading a text file into a string, you usually don't know what size the file has, 
so you can't decide how much memory to allocate until you run the program.

* You want to allocate memory which will persist after leaving the current scope. For instance, you may want to write a function `string readfile(string filename)` 
that returns the contents of a file. In this case, even if the stack could hold the entire file contents, you could not return from a 
function and keep the allocated memory block.

Compared to other languages, dynamic allocation by the **you** in C++ is often unnecessary. C++ has a neat construct called a destructor, which is a mechanism that 
allows you to manage resources by aligning the lifetime of the resource with the lifetime of a variable. 
This technique is called RAII ([Resource Acquisition Is Initialization](https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization)) and is a huge
upside in using C++. In other words, we are removing the necessity to use the first reason to use dynamic allocation above, by making it not the code writer's 
problem. Objects "wrap" resources within them. std::string is a perfect example. Observe the following code:
```c++
int main(int argc, char* argv[]) {
    std::string s(argv[0]);
}
```
Wait a minute, we're actually allocating a variable amount of memory here, as the size of s is an input to the program. How? well, 
the std::string object allocates memory using the heap in its constructor and releases it in its destructor. The destructor is automatically invoked
when we are about to leave the scope where the variable `s` exists.
In this case, you did not need to manually manage any resources for `s` and still got the benefits of dynamic memory allocation.

In other words, doing the following is bad practice:

```c++
int main(int argc, char* argv[]) {
    std::string *s = new std::string(argv[0]);
    delete s;
}
```
While it behaves identically to the previous snippet, there is more typing and you are unecessarily introducing the risk of forgetting to deallocate memory. 
It does this with no apparent benefit. Objects created by `new` must be eventually deleted else they leak. The destructor won't be called, memory won't be freed.

To sum up the benefits of the approach (automatic allocation with RAII):

* Faster to type
* Faster to run because you no longer need a garbage collector (which C++ does not have)
* Less prone to memory/resource leaks.
* And a nuanced reason, consider the following code:
```c++
class Box {
public:
    Box();		// Constructor
    ~Box();		// Destructor
    std::string* mItem;
};

Box::Box() {
    mItem = new std::string("toy_car");
}

Box::~Box() {
    delete mItem;
}
```
This is actually problematic in C++, the reason being that `std::string` properly defines a copy constructor. Consider what happens with the following code:
```c++
int main() {
    Box b1;
    Box b2 = b1;
}
```
When exiting the `main()` function, the destructor for both `b1` and `b2` are called, but b1 and b2 will point to the same `std:string` in the heap. This will lead to 
delete being called on the same `std:string` twice, causing the program to crash. The remedy is simple:
```c++
class Box {
public:
    Box();
    std::string mItem;
};

Box::Box() {
    mItem = "toy_car";
}
```
Just let the `std:string` manage its own memory. Whenever an object is about to be destructed, it will automatically call the destructors
of all its member variables. This creates an automatic chain of destruction, where you don't need to manage any memory, as long as you are using modern
C++ containers like `std:string`, `std:vector`, etc. Every parent in the hierarchy will destruct its children. Basically, it's better than the sum of its parts. 
The whole mechanism composes. It scales elegantly.

```c++
class Warehouse{
    Box boxes[4];	// Using the Box class from before
};

int main() {
    Warehouse warehouse;
}
```
allocates four `std::string` instances, four `Box` instances, one `Warehouse` instance and all the std:string's contents and everything is freed automacically.

Extensive use of RAII is considered a best practice in C++ because of all the reasons above.

Now that we've disbanded the first reason to use dynamic allocation, what can we do about the second reason?

## Smart Pointers

As opposed to using regular pointers if we need a resource in a different scope and having to deal with the aformentioned problems with dynamic memory
allocation, smart pointers like `unique_ptr`, `shared_ptr` solve the dangling reference problem, but they require coding discipline and have other 
potential issues (like copyability and reference loops, however the latter can be overcome with the use of `weak_ptr`).